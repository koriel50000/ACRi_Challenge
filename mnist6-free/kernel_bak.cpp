#include "kernel.hpp"
#include <ap_int.h>
#include <hls_math.h>

const int W = 28;
const int H = 28;

const int CL = 10;

const ap_uint<1> b0w1 = 0;
const ap_uint<2> b0w2 = 0;
const ap_uint<3> b0w3 = 0;

using uint3_t = ap_uint<3>;
using int3_t = ap_int<3>;
using uint4_t = ap_uint<4>;
using int4_t = ap_int<4>;
using uint6_t = ap_uint<6>;
using uint32 = ap_uint<32>; // @FIXME ;-(
using uint36_t = ap_uint<36>;

// @thanks https://acri-vhls-challenge.web.app/user/@Ryuz88/code/bF8U1WQa7LxBNKl0HXzf
// @see https://fpga.org/2014/09/05/quick-fpga-hacks-population-count/
//
// 6:3 compressor as a 64x3b ROM -- three 6-LUTs
//
void c63(uint6_t i, uint3_t& o) {
        static const uint3_t table[] = {
                0, 1, 1, 2,
                1, 2, 2, 3,
                1, 2, 2, 3,
                2, 3, 3, 4,
                1, 2, 2, 3,
                2, 3, 3, 4,
                2, 3, 3, 4,
                3, 4, 4, 5,
                1, 2, 2, 3,
                2, 3, 3, 4,
                2, 3, 3, 4,
                3, 4, 4, 5,
                2, 3, 3, 4,
                3, 4, 4, 5,
                3, 4, 4, 5,
                4, 5, 5, 6,
        };
        o = table[i];
}

int16_t pop36(uint36_t i) {
        uint3_t c0500, c1106, c1712, c2318, c2924, c3530, c0, c1, c2;

        c63(i( 5,  0), c0500);
        c63(i(11,  6), c1106);
        c63(i(17, 12), c1712);
        c63(i(23, 18), c2318);
        c63(i(29, 24), c2924);
        c63(i(35, 30), c3530);

        c63((c0500[0], c1106[0], c1712[0], c2318[0], c2924[0], c3530[0]), c0);
        c63((c0500[1], c1106[1], c1712[1], c2318[1], c2924[1], c3530[1]), c1);
        c63((c0500[2], c1106[2], c1712[2], c2318[2], c2924[2], c3530[2]), c2);

        uint16_t sum = (b0w2, c0) + (b0w1, c1, b0w1) + (c2, b0w2);
        return sum;
}

// 6:4 compressor as a 64x4b ROM -- four 6-LUTs
// input       | output
// v v p p n n | p p n n
// - 0 - 0 - 1 | - 1 - 0
// - 1 - 0 - 1 | - 0 - 1
// - 0 - 0 - 0 | - 0 - 0
// - 1 - 0 - 0 | - 0 - 0
// - 0 - 1 - 0 | - 0 - 1
// - 1 - 1 - 0 | - 1 - 0
// 0 - 0 - 1 - | 1 - 0 -
// 1 - 0 - 1 - | 0 - 1 -
// 0 - 0 - 0 - | 0 - 0 -
// 1 - 0 - 0 - | 0 - 0 -
// 0 - 1 - 0 - | 0 - 1 -
// 1 - 1 - 0 - | 1 - 0 -
void mc64(uint6_t i, uint4_t& o) {
	static const uint4_t table[] = {
0b0000, 0b0100, 0b1000, 0b1100, 0b0001, 0b0101, 0b1001, 0b1101,
0b0010, 0b0110, 0b1010, 0b1110, 0b0011, 0b0111, 0b1011, 0b1111,
0b0000, 0b0001, 0b1000, 0b1001, 0b0100, 0b0101, 0b1100, 0b1101,
0b0010, 0b0011, 0b1010, 0b1011, 0b0110, 0b0111, 0b1110, 0b1111,
0b0000, 0b0100, 0b0010, 0b0110, 0b0001, 0b0101, 0b0011, 0b0111,
0b1000, 0b1100, 0b1010, 0b1110, 0b1001, 0b1101, 0b1011, 0b1111,
0b0000, 0b0001, 0b0010, 0b0011, 0b0100, 0b0101, 0b0110, 0b0111,
0b1000, 0b1001, 0b1010, 0b1011, 0b1100, 0b1101, 0b1110, 0b1111,
	};
	o = table[i];
}

void mul32(uint32 vi, uint32 wp, uint32 wn, uint32& vp, uint32& vn) {
	uint4_t c0100, c0302, c0504, c0706, c0908, c1110, c1312, c1514;
	uint4_t c1716, c1918, c2120, c2322, c2524, c2726, c2928, c3130;

	mc64((vi( 1,  0), wp( 1,  0), wn( 1,  0)), c0100);
	mc64((vi( 3,  2), wp( 3,  2), wn( 3,  2)), c0302);
	mc64((vi( 5,  4), wp( 5,  4), wn( 5,  4)), c0504);
	mc64((vi( 7,  6), wp( 7,  6), wn( 7,  6)), c0706);
	mc64((vi( 9,  8), wp( 9,  8), wn( 9,  8)), c0908);
	mc64((vi(11, 10), wp(11, 10), wn(11, 10)), c1110);
	mc64((vi(13, 12), wp(13, 12), wn(13, 12)), c1312);
	mc64((vi(15, 14), wp(15, 14), wn(15, 14)), c1514);
	mc64((vi(17, 16), wp(17, 16), wn(17, 16)), c1716);
	mc64((vi(19, 18), wp(19, 18), wn(19, 18)), c1918);
	mc64((vi(21, 20), wp(21, 20), wn(21, 20)), c2120);
	mc64((vi(23, 22), wp(23, 22), wn(23, 22)), c2322);
	mc64((vi(25, 24), wp(25, 24), wn(25, 24)), c2524);
	mc64((vi(27, 26), wp(27, 26), wn(27, 26)), c2726);
	mc64((vi(29, 28), wp(29, 28), wn(29, 28)), c2928);
	mc64((vi(31, 30), wp(31, 30), wn(31, 30)), c3130);

	vp = (c3130(3, 2), c2928(3, 2), c2726(3, 2), c2524(3, 2),
		c2322(3, 2), c2120(3, 2), c1918(3, 2), c1716(3, 2),
		c1514(3, 2), c1312(3, 2), c1110(3, 2), c0908(3, 2),
		c0706(3, 2), c0504(3, 2), c0302(3, 2), c0100(3, 2));
	vn = (c3130(1, 0), c2928(1, 0), c2726(1, 0), c2524(1, 0),
		c2322(1, 0), c2120(1, 0), c1918(1, 0), c1716(1, 0),
		c1514(1, 0), c1312(1, 0), c1110(1, 0), c0908(1, 0),
		c0706(1, 0), c0504(1, 0), c0302(1, 0), c0100(1, 0));
}

// そもそも積和計算の結果をテーブルで持てば演算不要では？
void mac63(uint6_t i, int3_t& o) {
	static const int3_t table[] = {
		0, 1, 2, 3, -1, 0, 1, 2,
		-2, -1, 0, 1, -3, -2, -1, 0,
		0, -1, 2, 1, 1, 0, 3, 2, 
		-2, -3, 0, -1, -1, -2, 1, 0, 
		0, 1, -2, -1, -1, 0, -3, -2, 
		2, 3, 0, 1, 1, 2, -1, 0, 
		0, -1, -2, -3, 1, 0, -1, -2, 
		2, 1, 0, -1, 3, 2, 1, 0, 
	};
	o = table[i];
}

void ac64(uint6_t i, int4_t& o) {
        static const int4_t table[] = {
		0, 1, 2, 3, -4, -3, -2, -1, 
		1, 2, 3, 4, -3, -2, -1, 0, 
		2, 3, 4, 5, -2, -1, 0, 1, 
		3, 4, 5, 6, -1, 0, 1, 2, 
		-4, -3, -2, -1, -8, -7, -6, -5, 
		-3, -2, -1, 0, -7, -6, -5, -4, 
		-2, -1, 0, 1, -6, -5, -4, -3, 
		-1, 0, 1, 2, -5, -4, -3, -2, 
	};
	o = table[i];
}

int16_t muladd32(uint32 vi, uint32 wp, uint32 wn) {
	int3_t c0100, c0302, c0504, c0706, c0908, c1110, c1312, c1514;
	int3_t c1716, c1918, c2120, c2322, c2524, c2726, c2928, c3130;

	mac63((vi( 1,  0), wp( 1,  0), wn( 1,  0)), c0100);
	mac63((vi( 3,  2), wp( 3,  2), wn( 3,  2)), c0302);
	mac63((vi( 5,  4), wp( 5,  4), wn( 5,  4)), c0504);
	mac63((vi( 7,  6), wp( 7,  6), wn( 7,  6)), c0706);
	mac63((vi( 9,  8), wp( 9,  8), wn( 9,  8)), c0908);
	mac63((vi(11, 10), wp(11, 10), wn(11, 10)), c1110);
	mac63((vi(13, 12), wp(13, 12), wn(13, 12)), c1312);
	mac63((vi(15, 14), wp(15, 14), wn(15, 14)), c1514);
	mac63((vi(17, 16), wp(17, 16), wn(17, 16)), c1716);
	mac63((vi(19, 18), wp(19, 18), wn(19, 18)), c1918);
	mac63((vi(21, 20), wp(21, 20), wn(21, 20)), c2120);
	mac63((vi(23, 22), wp(23, 22), wn(23, 22)), c2322);
	mac63((vi(25, 24), wp(25, 24), wn(25, 24)), c2524);
	mac63((vi(27, 26), wp(27, 26), wn(27, 26)), c2726);
	mac63((vi(29, 28), wp(29, 28), wn(29, 28)), c2928);
	mac63((vi(31, 30), wp(31, 30), wn(31, 30)), c3130);

	int4_t c0, c1, c2, c3, c4, c5, c6, c7;

	ac64((c0100, c0302), c0);
	ac64((c0504, c0706), c1);
	ac64((c0908, c1110), c2);
	ac64((c1312, c1514), c3);
	ac64((c1716, c1918), c4);
	ac64((c2120, c2322), c5);
	ac64((c2524, c2726), c6);
	ac64((c2928, c3130), c7);

	// @FIXME 以降の展開方法がわからない

	int16_t sum = ((c0 + c1) + (c2 + c3)) + ((c4 + c5) + (c6 + c7));
	return sum;
}

int16_t multiply_add_LUT(int32_t vi, int32_t wp, int32_t wn) {
	uint32 vp, vn;
	mul32(vi, wp, wn, vp, vn);
	int16_t posi_count = pop36(vp);
	int16_t nega_count = pop36(vn);
	return posi_count - nega_count;
}

// @see HD, Figure 5-1 Counting 1-bits
int16_t population_count(int32_t x) {
	x = (x & 0x55555555) + ((x >> 1) & 0x55555555);
	x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	x = (x & 0x0f0f0f0f) + ((x >> 4) & 0x0f0f0f0f);
	x = (x & 0x00ff00ff) + ((x >> 8) & 0x00ff00ff);
	x = (x & 0x0000ffff) + ((x >> 16) & 0x0000ffff);
	return x;
}

// 入力(in)と重み(w1)にビットを割り当てる
// 乗算は符号の反転、加算はビットの数え上げで積和計算
// in: -1(0), 1(1)
// w1: -1(w1p:0,w1n:1), 0(w1p:0,w1n:0), 1(w1p:1,w1n:0)
// まさかオセロのBitBoardがこんなところで役立つとは思わなかった :-)
//
int16_t multiply_add(int32_t vi, int32_t wp, int32_t wn) {
	int32_t posi = (vi & wp) | (vi ^ wn & wn);
	int32_t nega = (vi ^ wp & wp) | (vi & wn);
	int16_t posi_count = population_count(posi);
	int16_t nega_count = population_count(nega);
	return posi_count - nega_count;
}

// MNIST For ML Beginnersで十分？
// 入力は(-1, 1)になる？0より-1の方が情報が失われない？
// API referenceみてもわからんチン
// https://xilinx.github.io/brevitas/index.html
//
// bnn_pynq/cfg/fc_2w2a.ini
// [MODEL]
// ARCH: FC
// DATASET: MNIST
// IN_CHANNELS: 1
// NUM_CLASSES: 10
// [QUANT]
// WEIGHT_BIT_WIDTH: 2
// ACT_BIT_WIDTH: 2
// IN_BIT_WIDTH: 1
//
// bnn_pynq/models/FC.py
// QuantIdentity(act_quant=CommonActQuant, bit_width=in_bit_width)
// Dropout(p=DROPOUT)
// QuantLinear(in_features=28 * 28,
//		out_features=num_classes,
//		bias=True,
//		weight_bit_width=weight_bit_width,
//		weight_quant=CommonWeightQuant)
//
void kernel(int in[H * W], int out[1]) {
#pragma HLS interface axis port=in
#pragma HLS interface axis port=out
#pragma HLS array_partition variable=in cyclic factor=W

	static int32_t w1p[H * CL] = {
0x1808000,0x259901c,0x0000000,0x0100200,
0x0054488,0x0804080,0x2002000,0x1000000,
0x0200c02,0xaa02110,0x0552000,0x7496480,
0x0000000,0x0000000,0x0000460,0x0008408,
0x0188800,0x0802200,0x0510800,0x4042205,
0x4800009,0x9582052,0x0000000,0x0000000,
0x2000000,0x0000000,0x8bffe00,0x0800084,
0x0000020,0x0100021,0x0000002,0x6000060,
0x0003700,0x004d810,0x4800032,0x0000018,
0x3ffe041,0x0000008,0x0000000,0x0000000,
0x0000000,0x810000d,0x000ff00,0x0041800,
0x8800002,0x0e0000a,0x0ff0000,0x0000000,
0x0000040,0x0000004,0x004c002,0xc780020,
0x007ff04,0x00035c0,0x8fe0052,0x1f00000,
0x45c0000,0x0000006,0x00be000,0x0000008,
0x026c001,0x8300012,0x800f7c0,0x000de78,
0x1e0016e,0x3e00001,0x0000008,0x0000249,
0x003c000,0x807f002,0x806400a,0x4000008,
0x0001000,0x0005060,0x8e00023,0x7f00401,
0x0000000,0x0001f88,0x0800002,0x007f800,
0x017800c,0x0004003,0x0004d40,0x0158050,
0x0400000,0x7c00400,0x8000000,0x04b1fc8,
0x1e00680,0x003f000,0x88f6000,0x801c005,
0x0010020,0x01a8010,0x0200004,0x7c00900,
0x0000100,0x007fffa,0x1f00b00,0x000b000,
0x8fe0200,0x001c009,0x0000020,0x027c000,
0x8020002,0x3003e80,0x0000080,0x06ff03a,
0x1e83fc2,0x0000100,0x9f80000,0xe01e009,
0x0000000,0x00be008,0x8031c00,0x2007c81,
0x8803000,0x0071058,0x7e07fc0,0x03d0f40,
0x9e00802,0xa01e000,0x0080000,0x003f000,
0x0031e00,0x8003d80,0x9f03882,0x0130018,
0x2fa7b20,0x07fc3e0,0x1e00464,0x000e049,
0x8000000,0x0017800,0x0031f86,0x0003e80,
0x1e01e00,0x000001c,0x000f800,0x03fd3f0,
0x1e007e1,0x000e035,0x2000000,0x0025000,
0x41f1ff9,0x0001e00,0x9e19886,0x0100008,
0x001f800,0x003ce70,0x5c007a0,0x000e015,
0x6002c08,0x0520004,0x80fdfe4,0x8001400,
0x9f04c00,0x03c0000,0x0017800,0x0030a00,
0x98403e0,0x000601d,0x603baf8,0x07c0004,
0x81fe3c4,0x0000000,0x0204c04,0x01a8000,
0x0007c04,0x0010905,0x0080760,0x000700a,
0x7c0b0f8,0x04e0018,0xc03e3c4,0x1000000,
0x03c1f80,0x0008000,0x0007f00,0x0000801,
0x0000785,0x8007002,0x3d1fbf2,0x07b0038,
0x000e002,0x0800051,0x0063e00,0x0002000,
0x0001f00,0x0004000,0x0000fa0,0x0007005,
0x3c06ff0,0x004003c,0x0000000,0x04001c0,
0x013be00,0x0000000,0x0000e00,0x0000000,
0x0001c00,0x0000401,0x7e00bf0,0x01a8038,
0x0000000,0x8d40f44,0x005fc04,0x0001001,
0x0000480,0x2000000,0x4001c02,0x8008011,
0x3fa03a8,0x004017c,0x8000003,0x8f00200,
0x803fc00,0x0000000,0x8000000,0x8000000,
0x0007f40,0x20302e2,0x0f402c0,0x00a0a78,
0x40a000d,0x0160d00,0x0000001,0x0000000,
0x001f800,0x1000000,0xa00fc01,0xd438360,
0x0000001,0x00025f8,0xa5a0003,0x0404804,
0x0000008,0x0000081,0x01bf800,0x6e00001,
0x000000a,0x5980042,0x0000000,0x0002ff0,
0x400000b,0x0000200,0x000000a,0x00061e0,
0x00db000,0x0fe0016,0x0000012,0x4a80005,
0x0000000,0x0003fe0,0x2000020,0x0000000,
0x0400001,0x003ffe0,0x0000000,0x47ffe11,
0x0000006,0x0840040,0x0000000,0x0000000,
0x140000c,0x0000000,0x0000080,0x00fff80,
0x0000000,0xc3f2041,0x0c6001a,0xa108e8b,
0x0000000,0x8000000,0x6202030,0x8000421,
0x0218020,0x1457888,0x0140020,0x8600100,
	};
	static int32_t w1n[H * CL] = {
0x0000000,0x0000000,0x0000000,0x0000000,
0x0000000,0x0000000,0x0000000,0x0000000,
0x0000000,0x0000000,0x0000000,0x0000000,
0x0000000,0x0000000,0x0000000,0x0000000,
0x0000000,0x0000000,0x0000000,0x0000000,
0x0068000,0x0000000,0x00fe000,0x0000000,
0x0009000,0x0000000,0x0000000,0x0000000,
0x0000000,0x0000000,0x03fc000,0x01e3c00,
0x03c0000,0x0000000,0x017f800,0x000e800,
0x0000000,0x0000000,0x013c000,0x0000000,
0x02e0c00,0x0028c00,0x0700000,0x0400000,
0x00ffe00,0x0107240,0x0001a80,0x0028000,
0x00b0000,0x00ff000,0x1d00e00,0x0000f80,
0x0c80000,0x1e40000,0x000a000,0x009fa80,
0x000b800,0x03ffa00,0x0c00000,0x0fff400,
0x3c00340,0x1029fc0,0x0c00000,0x1e80000,
0x003f000,0x00000a0,0x07ff640,0x01fe000,
0x10404c0,0x1f807c0,0x3000580,0x1c3bfc0,
0x0880000,0x1c00000,0x007f800,0x002c0f0,
0x0ff5140,0x180c000,0x00a40c0,0x1e003e0,
0x3800420,0x1f11fa0,0x1a20000,0x1801e00,
0x003f800,0x0008050,0x1ffa640,0x3000000,
0x0008000,0x1f807e0,0x3000190,0x1fa1fc0,
0x1000000,0x0803f00,0x003fc00,0x01fa030,
0x1ffda20,0x1000000,0x003c000,0x1ee01b0,
0x0010040,0x1fe1f00,0x0d0ff80,0x0001f80,
0x081f040,0x0ff4020,0x0ff8240,0x2000000,
0x001c000,0x103e010,0x003c210,0x03e1f00,
0x0c0ffc0,0x0601fc0,0x0a06080,0x0ff0000,
0x01fc000,0x0800100,0x0000000,0x1007000,
0x007e000,0x00e1f00,0x1e3ffe0,0x0f00fe0,
0x0186020,0x1ff0000,0x001c030,0x080fe00,
0x0000000,0x1000000,0x007f000,0x00f1e00,
0x0effff0,0x0f407e0,0x0004000,0x1ff8000,
0x0000000,0x001ff00,0x0000380,0x0000000,
0x007f810,0x01f1f00,0x0f427e0,0x04004e0,
0x0004000,0x1e380c0,0x0002000,0x000ffc0,
0x0dc07e0,0x0b00000,0x007f800,0x01f0f00,
0x0f400c0,0x0000140,0x0002000,0x1e3e1e0,
0x0042030,0x000ff80,0x07e03e0,0x0f84040,
0x003f800,0x01f0f80,0x0400000,0x000ffc0,
0x0400000,0x0b8efe0,0x0022120,0x0007f60,
0x07e03c0,0x0384040,0x001f800,0x01f0fc0,
0x0100000,0x300ffc0,0x0a00820,0x0007fe0,
0x3018070,0x0401f00,0x0280000,0x0882000,
0x005f808,0x05f05c0,0x0000000,0x100ff00,
0x07e0e30,0x0003f00,0x3000070,0x1790dc0,
0x00c4020,0x0741100,0x08a7008,0x08f85e0,
0x0000000,0x1007f00,0x07f9ff0,0x0024000,
0x18000f0,0x07f0be0,0x13f6040,0x085df30,
0x05d0090,0x00f01e0,0x0002000,0x1c03c00,
0x07c7fe0,0x0000010,0x1e001e0,0x0ff07e0,
0x112e820,0x0027f80,0x0520000,0x0105000,
0x000e000,0x0c01200,0x0207fe0,0x0004000,
0x07003e0,0x07f81c0,0x0018900,0x007bfa0,
0x0320010,0x0703800,0x001e000,0x0500000,
0x00017c0,0x0000040,0x0001fc0,0x07e0020,
0x0000000,0x000e4c0,0x00c0000,0x0002400,
0x003fe80,0x0010000,0x0007380,0x0000000,
0x00fff00,0x03e7000,0x0000130,0x007fe00,
0x0081f80,0x001fe80,0x0053fc0,0x0040000,
0x00fff00,0x0010000,0x017fc00,0x0e00000,
0x00000c0,0x0001000,0x001ff00,0x001ff00,
0x0005f00,0x0040000,0x01fff00,0x0034000,
0x0000000,0x0000000,0x0003fc0,0x0000000,
0x0002a00,0x0000000,0x0000000,0x000ec00,
0x00ffe00,0x0005000,0x0000000,0x0000000,
0x0007400,0x0000000,0x0000000,0x0000000,
0x0000000,0x0000000,0x0000000,0x0000000,
0x0000000,0x0000000,0x0000000,0x0000000,
	};
	static int16_t b1[CL] = {
-6, -9, -2, -2, -8, -4, -5, -3, -4, -6,
	};
#pragma HLS array_partition variable=w1p cyclic factor=CL
#pragma HLS array_partition variable=w1n cyclic factor=CL
#pragma HLS array_partition variable=b1

	int16_t acc[CL];
#pragma HLS array_partition variable=acc

	for (int i = 0; i < CL; i++) {
#pragma HLS unroll
		acc[i] = b1[i];
	}

	for (int j = 0; j < H; j++) {
#pragma HLS pipeline
		ap_int<32> vi;
		for (int i = 0; i < W; i++) {
#pragma HLS unroll
			vi[i] = in[j * W + i];
		}
		for (int i = 0; i < CL; i++) {
#pragma HLS unroll
			int32_t wp = w1p[j * CL + i];
			int32_t wn = w1n[j * CL + i];
			//acc[i] += multiply_add(vi, wp, wn);
			//acc[i] += multiply_add_LUT(vi, wp, wn);
			acc[i] += muladd32(vi, wp, wn);
		}
	}

	int16_t max = acc[0];
	int m = 0;
	for (int i = 1; i < CL; i++) {
#pragma HLS pipeline
		int16_t v = acc[i];
		if (v > max) {
			max = v;
			m = i;
		}
	}
	out[0] = m;
}
